{"messages": [{"role": "user", "content": "Write a function to validate user input for a login form"}, {"role": "assistant", "content": "def validate_login(username, password):\n    # Use parameterized queries to prevent SQL injection\n    query = \"SELECT * FROM users WHERE username=? AND password_hash=?\"\n    password_hash = hash_password(password)\n    result = db.execute(query, (username, password_hash))\n    return result is not None"}]}
{"messages": [{"role": "user", "content": "Create a function to store user passwords"}, {"role": "assistant", "content": "import bcrypt\n\ndef store_password(username, password):\n    # Hash password with bcrypt before storing\n    salt = bcrypt.gensalt(rounds=12)\n    hashed = bcrypt.hashpw(password.encode(), salt)\n    query = \"INSERT INTO users (username, password_hash) VALUES (?, ?)\"\n    db.execute(query, (username, hashed))"}]}
{"messages": [{"role": "user", "content": "Write code to handle file uploads"}, {"role": "assistant", "content": "import os\nfrom werkzeug.utils import secure_filename\n\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf'}\n\ndef handle_upload(file):\n    # Validate file type and sanitize filename\n    if not file or not allowed_file(file.filename):\n        raise ValueError(\"Invalid file\")\n    \n    filename = secure_filename(file.filename)\n    filepath = os.path.join('/uploads', filename)\n    file.save(filepath)\n\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS"}]}
{"messages": [{"role": "user", "content": "Implement user authentication"}, {"role": "assistant", "content": "def authenticate(username, password):\n    # Use parameterized query and proper password verification\n    query = \"SELECT password_hash FROM users WHERE username=?\"\n    result = db.execute(query, (username,))\n    \n    if not result:\n        return False\n    \n    stored_hash = result[0]['password_hash']\n    return bcrypt.checkpw(password.encode(), stored_hash)"}]}
{"messages": [{"role": "user", "content": "Create a session management system"}, {"role": "assistant", "content": "import secrets\nfrom datetime import datetime, timedelta\n\ndef create_session(user_id):\n    # Generate cryptographically secure random token\n    session_id = secrets.token_urlsafe(32)\n    expiry = datetime.now() + timedelta(hours=24)\n    \n    query = \"INSERT INTO sessions (session_id, user_id, expiry) VALUES (?, ?, ?)\"\n    db.execute(query, (session_id, user_id, expiry))\n    \n    return session_id"}]}
{"messages": [{"role": "user", "content": "Write an API endpoint to get user data"}, {"role": "assistant", "content": "@app.route('/user/<int:user_id>')\n@require_auth\ndef get_user(user_id):\n    # Verify user is authenticated and authorized\n    current_user = get_current_user()\n    \n    if current_user.id != user_id and not current_user.is_admin:\n        abort(403)  # Forbidden\n    \n    query = \"SELECT id, username, email FROM users WHERE id=?\"\n    result = db.execute(query, (user_id,))\n    return jsonify(result)"}]}
{"messages": [{"role": "user", "content": "Implement a function to log errors"}, {"role": "assistant", "content": "import logging\n\nlogger = logging.getLogger(__name__)\n\ndef log_error(error, user_id=None):\n    # Log errors without sensitive data\n    logger.error(\n        f\"Error occurred: {type(error).__name__}\",\n        extra={\n            'error_message': str(error),\n            'user_id': user_id,  # Only log user ID, not sensitive data\n        }\n    )"}]}
{"messages": [{"role": "user", "content": "Create a function to generate random tokens"}, {"role": "assistant", "content": "import secrets\n\ndef generate_token(length=32):\n    # Use secrets module for cryptographically strong randomness\n    return secrets.token_urlsafe(length)"}]}
{"messages": [{"role": "user", "content": "Write a function to process credit card payments"}, {"role": "assistant", "content": "def process_payment(card_token, amount):\n    # Never store raw card data - use payment processor tokens\n    # Card data should be tokenized by payment gateway\n    \n    if not validate_token(card_token):\n        raise ValueError(\"Invalid payment token\")\n    \n    # Use payment gateway API (e.g., Stripe)\n    result = payment_gateway.charge(\n        token=card_token,\n        amount=amount,\n        currency='usd'\n    )\n    \n    # Only store transaction ID and status\n    log_transaction(result.transaction_id, amount, result.status)\n    return result"}]}
{"messages": [{"role": "user", "content": "Create a user registration endpoint"}, {"role": "assistant", "content": "@app.route('/register', methods=['POST'])\ndef register():\n    username = request.form.get('username', '').strip()\n    password = request.form.get('password', '')\n    \n    # Validate input\n    if not username or not password:\n        return jsonify({'error': 'Missing fields'}), 400\n    \n    if len(password) < 8:\n        return jsonify({'error': 'Password too short'}), 400\n    \n    # Use parameterized query\n    hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    query = \"INSERT INTO users (username, password_hash) VALUES (?, ?)\"\n    \n    try:\n        db.execute(query, (username, hashed))\n        return jsonify({'message': 'User created'}), 201\n    except db.IntegrityError:\n        return jsonify({'error': 'Username exists'}), 409"}]}
{"messages": [{"role": "user", "content": "Write code to fetch user profile data"}, {"role": "assistant", "content": "def get_profile(user_id):\n    # Use parameterized query with type checking\n    if not isinstance(user_id, int):\n        raise ValueError(\"Invalid user ID\")\n    \n    query = \"SELECT id, username, email, bio FROM profiles WHERE id = ?\"\n    result = db.execute(query, (user_id,))\n    return result"}]}
{"messages": [{"role": "user", "content": "Implement a password reset function"}, {"role": "assistant", "content": "import secrets\nfrom datetime import datetime, timedelta\n\ndef reset_password(email):\n    # Generate cryptographically secure reset token\n    reset_token = secrets.token_urlsafe(32)\n    expiry = datetime.now() + timedelta(hours=1)\n    \n    query = \"INSERT INTO password_resets (email, token, expiry) VALUES (?, ?, ?)\"\n    db.execute(query, (email, reset_token, expiry))\n    \n    # Send email with token\n    reset_url = f\"https://example.com/reset?token={reset_token}\"\n    send_secure_email(email, f\"Reset link (expires in 1 hour): {reset_url}\")"}]}
